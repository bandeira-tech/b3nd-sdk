/**
 * Server Identity Key Management
 *
 * Loads server keys from environment variables only.
 * No generation, no storage - developers manage their own keys.
 *
 * Keys are loaded on startup and used throughout server lifetime.
 * Private keys never leave memory.
 */

import { decodeHex } from "@std/encoding/hex";
import { sign } from "@b3nd/sdk/encrypt";

interface ServerKeys {
  identityKey: {
    privateKeyPem: string;
    publicKeyHex: string;
  };
  encryptionKey: {
    privateKeyPem: string;
    publicKeyHex: string;
  };
}

/**
 * Load server keys from environment variables
 *
 * Required env vars:
 * - SERVER_IDENTITY_PRIVATE_KEY_PEM: Ed25519 private key (PEM format)
 * - SERVER_IDENTITY_PUBLIC_KEY_HEX: Ed25519 public key (hex format)
 * - SERVER_ENCRYPTION_PRIVATE_KEY_PEM: X25519 private key (PEM format)
 * - SERVER_ENCRYPTION_PUBLIC_KEY_HEX: X25519 public key (hex format)
 *
 * Keys should be generated by developers using their preferred method.
 * Example: openssl genpkey -algorithm ed25519 -outform PEM
 */
export function loadServerKeys(): ServerKeys {
  const unwrapEnvValue = (value: string) => {
    const trimmed = value.trim();
    if (
      (trimmed.startsWith('"') && trimmed.endsWith('"')) ||
      (trimmed.startsWith("'") && trimmed.endsWith("'"))
    ) {
      return trimmed.slice(1, -1);
    }
    return trimmed;
  };

  const identityPrivateKeyPemRaw = Deno.env.get(
    "SERVER_IDENTITY_PRIVATE_KEY_PEM",
  );
  const identityPublicKeyHexRaw = Deno.env.get(
    "SERVER_IDENTITY_PUBLIC_KEY_HEX",
  );
  const encryptionPrivateKeyPemRaw = Deno.env.get(
    "SERVER_ENCRYPTION_PRIVATE_KEY_PEM",
  );
  const encryptionPublicKeyHexRaw = Deno.env.get(
    "SERVER_ENCRYPTION_PUBLIC_KEY_HEX",
  );

  if (!identityPrivateKeyPemRaw) {
    throw new Error(
      "SERVER_IDENTITY_PRIVATE_KEY_PEM environment variable is required"
    );
  }

  if (!identityPublicKeyHexRaw) {
    throw new Error(
      "SERVER_IDENTITY_PUBLIC_KEY_HEX environment variable is required"
    );
  }

  if (!encryptionPrivateKeyPemRaw) {
    throw new Error(
      "SERVER_ENCRYPTION_PRIVATE_KEY_PEM environment variable is required"
    );
  }

  if (!encryptionPublicKeyHexRaw) {
    throw new Error(
      "SERVER_ENCRYPTION_PUBLIC_KEY_HEX environment variable is required"
    );
  }

  const identityPrivateKeyPem = unwrapEnvValue(identityPrivateKeyPemRaw);
  const identityPublicKeyHex = unwrapEnvValue(identityPublicKeyHexRaw);
  const encryptionPrivateKeyPem = unwrapEnvValue(encryptionPrivateKeyPemRaw);
  const encryptionPublicKeyHex = unwrapEnvValue(encryptionPublicKeyHexRaw);

  // Validate that public keys are exactly 64 hex characters (32 bytes raw)
  if (identityPublicKeyHex.length !== 64) {
    throw new Error(
      `SERVER_IDENTITY_PUBLIC_KEY_HEX must be exactly 64 hex characters (32 bytes), got ${identityPublicKeyHex.length}. ` +
      `Your key appears to be in DER format. Generate fresh keys via: bnd server-keys env`
    );
  }
  if (encryptionPublicKeyHex.length !== 64) {
    throw new Error(
      `SERVER_ENCRYPTION_PUBLIC_KEY_HEX must be exactly 64 hex characters (32 bytes), got ${encryptionPublicKeyHex.length}. ` +
      `Your key appears to be in DER format. Generate fresh keys via: bnd server-keys env`
    );
  }

  // Validate that public keys are valid hex
  try {
    decodeHex(identityPublicKeyHex);
  } catch {
    throw new Error("SERVER_IDENTITY_PUBLIC_KEY_HEX is not valid hex");
  }

  try {
    decodeHex(encryptionPublicKeyHex);
  } catch {
    throw new Error("SERVER_ENCRYPTION_PUBLIC_KEY_HEX is not valid hex");
  }

  console.log("âœ… Server keys validated:");
  console.log(`   Identity: ${identityPublicKeyHex.substring(0, 16)}...`);
  console.log(`   Encryption: ${encryptionPublicKeyHex.substring(0, 16)}...`);

  // Validate PEM format (basic check)
  if (
    !identityPrivateKeyPem.includes("-----BEGIN") ||
    !identityPrivateKeyPem.includes("-----END")
  ) {
    throw new Error("SERVER_IDENTITY_PRIVATE_KEY_PEM is not valid PEM format");
  }

  if (
    !encryptionPrivateKeyPem.includes("-----BEGIN") ||
    !encryptionPrivateKeyPem.includes("-----END")
  ) {
    throw new Error(
      "SERVER_ENCRYPTION_PRIVATE_KEY_PEM is not valid PEM format"
    );
  }

  return {
    identityKey: {
      privateKeyPem: identityPrivateKeyPem,
      publicKeyHex: identityPublicKeyHex,
    },
    encryptionKey: {
      privateKeyPem: encryptionPrivateKeyPem,
      publicKeyHex: encryptionPublicKeyHex,
    },
  };
}

/**
 * Sign payload with server's Ed25519 identity key
 * Uses @b3nd/sdk/encrypt sign function for consistency
 */
export async function signWithServerKey(
  privateKeyPem: string,
  data: unknown
): Promise<string> {
  try {
    const privateKey = await pemToCryptoKey(privateKeyPem, "Ed25519");
    return await sign(privateKey, data);
  } catch (error) {
    throw new Error(
      `Failed to sign data: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

/**
 * Convert PEM string to CryptoKey
 */
async function pemToCryptoKey(
  pem: string,
  algorithm: "Ed25519" | "X25519" = "Ed25519"
): Promise<CryptoKey> {
  const base64 = pem
    .split("\n")
    .filter((line) => !line.startsWith("-----"))
    .join("");

  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }

  const buffer = bytes.buffer.slice(
    bytes.byteOffset,
    bytes.byteOffset + bytes.byteLength
  ) as ArrayBuffer;

  if (algorithm === "Ed25519") {
    return await crypto.subtle.importKey(
      "pkcs8",
      buffer,
      { name: "Ed25519", namedCurve: "Ed25519" },
      false,
      ["sign"]
    );
  } else {
    return await crypto.subtle.importKey(
      "pkcs8",
      buffer,
      { name: "X25519", namedCurve: "X25519" },
      false,
      ["deriveBits"]
    );
  }
}
